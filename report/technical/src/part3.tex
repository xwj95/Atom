\section{整体设计}
\subsection{CPU整体设计}
本实验实现了基于标准32位MIPS指令集的子集的五级流水CPU，支持异常、中断、TLB等。

MIPS指令集的各条指令可以分解为取指（IF）、译码（ID）、执行（EX）、访存（MEM）和回写（WB）五个阶段，分别对应于本次实验需要实现的五个核心模块。模块内部采用组合逻辑电路实现，相邻模块之间的数据传输采用时序逻辑电路实现，每经过一个时钟周期，所有阶段分别将各自保存的结果交给下一个阶段，从而实现流水CPU。

此外，我们还实现了寄存器堆模块（Regfile）、HILO模块（HILO）、协处理器模块（CP0）和控制模块（CTRL）。寄存器堆模块在译码阶段实现，便于指令在译码阶段访问寄存器并得到相应的数据。HILO模块和协处理器模块在回写阶段实现。控制模块则用于控制整个流水线的暂停、清除等动作，因此不将其归入流水线中的某一个阶段。

流水线虽然能提高指令执行效率，但由此带来的冲突是不可避免的。我们对于流水线三种类型的冲突（结构冲突、数据冲突和控制冲突）分别进行了处理。
\begin{enumerate}
	\item 结构冲突
	
	指令在重叠执行过程中发生硬件资源冲突，在MIPS架构中主要是指取指阶段和访存阶段同时对存储器进行访问引起的冲突。解决方法是在设计数据通路时，采用资源重复设置的方法。如果指令和数据放在同一个存储器，可使用双端口存储器，一个端口存取数据，另一个端口取指令，这两个操作可以并行操作而不引起结构冲突。
	
	\item 数据冲突
	
	在同时重叠执行的几条指令中，一条指令依赖于前面指令执行结果，但是得不到执行结果造成的冲突（RAW，即Read After Write）。解决方法是在数据通路中加入流水线暂停和恢复机制（load相关），并引入数据前推技术，将执行结果提前送到其他模块，以供其他模块参考和使用。由于编译器调度容易出错，所以本项目中不在编译器上做优化。
	
	\item 控制冲突
	
	流水线中的分支指令或者其他需要改写PC的指令造成的冲突。解决方法是引入延时槽机制，这要求编译器在分支指令后插入空指令，对流水线的性能有一定的影响。
	
\end{enumerate}
\subsection{元件例化}
\subsection{数据通路图}
（数据通路图）
\subsection{异常处理}
本次实验要求实现精确异常处理，即确定异常发生的位置，确保该指令前的指令全部执行完毕，并将该指令后的指令从流水线上擦除。

为实现精确异常，必须要求异常发生的顺序与指令的顺序相同，而在流水线处理器上，异常会在流水线的不同阶段发生，带来潜在的问题。因此，先发生的异常并不立即处理，异常事件被暂时标记，并继续运行流水线；设计一个特殊的流水线阶段，专门用于处理异常。如果某一条指令运行到了流水线的这个阶段，那么就会进行异常处理，并且当前处于流水线其余阶段的指令的异常事件都会被忽略。如此就能保证在流水线处理器中实现“按指令执行的顺序处理异常，而不是按异常发生的顺序处理异常”。

ERET指令（异常返回指令）既要清除Status寄存器的EXL字段，从而使能中断（即设置Status寄存器的EXL字段为0，表示不再处于异常级），还要将EPC寄存器保存的地址恢复到PC中，从而返回到异常发生处继续执行。

（补充具体指令or异常中断的实现细节）

以下是一些可能用到的中断和异常的情况。

\begin{table}[H]
	\centering
	\begin{tabular}{lll}
		\hline
		异常号&异常名&描述\\
		\hline
		0&Interrupt&外部中断、异步发生，由硬件引起\\
		1&TLB Modified&内存修改异常，发生在Memory阶段\\
		2&TLBL&读未在TLB中映射的内存地址触发的异常\\
		3&TLBS&写未在TLB中映射的内存地址触发的异常\\
		4&ADEL&读访问一个非对齐地址触发的异常\\
		5&ADES&读访问一个非对齐地址触发的异常\\
		8&SYSCALL&系统调用\\
		10&RI&执行未定义指令异常\\
		11&Co-Processor Unavailable&试图访问不存在的协处理器异常\\
		23&Watch&Watch寄存器监控异常\\
		\hline
	\end{tabular}
\end{table}

下表列出可能用到的中断号。

\begin{table}[H]
	\centering
	\begin{tabular}{ll}
		\hline
		中断号&设备\\
		\hline
		0&系统计时器\\
		1&键盘\\
		3&通讯端口COM2\\
		4&通讯端口COM1\\
		\hline
	\end{tabular}
\end{table}

中断/异常处理过程如下：

\begin{enumerate}[(1)]
	\item 保存中断信息，主要是EPC，BadVaddr，Status，Cause等寄存器的信息
	
	\qquad EPC:存储异常处理之后程序恢复执行的地址。对于一般异常，当前发生错误的指令地址即为EPC应当保存的地址（如果发生异常的指令在延迟槽中，那么设置EPC寄存器的值为该指令的地址减4）；而对于硬件中断，由于是异步产生则可以任意设定一条并未执行完成的指令地址保存，但在进入下一步处理之前，该指令前的指令都应当被执行完。
	
	\qquad BadVAddr：捕捉最近一次地址错误或TLB异常（重填、失效、修改）时的虚拟地址。
	
	\qquad Status：将EXL位置为1，进入kernel模式进行中断处理。
	
	\qquad Cause：记录下异常号。
	
	\qquad EntryHi：TLB异常时，记录下BadVAddr的部分高位。
	
	\item 根据Cause中的异常号跳转到相应的异常处理函数入口
	
	\item 中断处理
	
	\item 通过调用ERET指令恢复现场，返回EPC所存地址执行并且将Status中的EXL重置为0表示进入user模式。
	
\end{enumerate}

\quad \\
实现思路：

在流水线的各个阶段收集异常信息，并传递到流水线访存阶段，在访存阶段统一处理异常信息。

在流水线访存阶段，处理器将结合协处理器CP0中相关寄存器的值，判断异常是否需要处理，如果需要处理，那么转移到该异常对应的处理例程入口地址，清除流水线上除回写阶段外的全部信息（回写阶段的指令要继续执行），同时修改协处理器CP0中相关寄存器的值。

如果是ERET指令，那么转移到EPC寄存器保存的地址处，同时，也要清除流水线上除回写阶段外的全部信息，修改协处理器CP0中相关寄存器的值。

其中，清除流水线上某个阶段的信息，实际上就是讲该阶段中的所有寄存器设置为初始值即可。

具体步骤如下：

\begin{enumerate}[(1)]
	\item 在可能发生异常的位置实现对异常的记录。
	
	\begin{enumerate}[(a)]
		\item 访存时可能发生ADEL，ADES，TLBM，TLBL，TLBS，Watch异常
		
		\item 译码后可能发生RI，SYSCALL，Co-ProcessorU异常
	\end{enumerate}
	\item 实现对中断的记录。
	
	\begin{enumerate}[(a)]
		\item 硬件产生中断时将信息写入CP0寄存器
	\end{enumerate}
	
	\item 根据异常记录信息判断是否产生异常。
	
	\item 进入异常处理流程。
	
\end{enumerate}