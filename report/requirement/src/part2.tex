\section{功能需求}
\subsection{CPU}
\subsubsection{ALU}
ALU负责实现双输入的算术、逻辑和移位运算功能，其中包括乘法运算，并完成指令系统的算术指令。

ALU的输入端为两个32位整数和一个8位操作码，输出端为32位整数（乘法运算除外），不给出标志位。

由于ALU需要实现的运算种类较多，我们在此不做列举。

%\begin{table}[ht]
%\centering
%\begin{tabular}{cccccc}
%\hline
%操作码&功能&描述&操作码&功能&描述\\
%\hline
%ADD&A + B&加法&NOR&$\sim$(A $\mid$ B)&或非\\
%SUB&A - B&减法&SLL&A $\gg$ B&逻辑左移\\
%AND&A $\&$ B&与&SRL&A $\ll$ B&逻辑右移\\
%OR&A $\mid$ B&或&SRA&A $\ggg$ B&算术右移\\
%XOR&A $\wedge$ B&异或&SLT&A $<$ B&比较\\
%\hline
%\end{tabular}
%\end{table}

\subsubsection{乘法器}
乘法器负责实现乘法功能，输入为两个32位整数，输出为两个32位整数，分别存放在LO和HI寄存器中。

乘法运算采用Verilog语言提供的乘法运算符实现。我们没有将乘法器作为一个独立的元件来实现，而是在ALU中加入乘法的操作码，将乘法器并入ALU中实现。

考虑到乘法运算需要的时间比较长，如果乘法指令需要多周期完成，那么就必须为流水线增加暂停机制，这将使流水线的设计复杂化。为尽可能简化流水线设计，可适当降低时钟频率，以使得乘法运算可以在一个时钟周期内完成运算。

\subsubsection{寄存器堆}
寄存器堆负责实现通用寄存器的读写和在数据通路中的控制，在流水线译码阶段读取一个或两个通用寄存器的数据（组合逻辑），并在流水线写回阶段将结果写入通用寄存器（时序逻辑）。

寄存器堆采用FPGA的逻辑单元来实现数据的存储，在32位MIPS架构下需要实现32个32位通用寄存器。

\subsubsection{CP0}
CP0是系统控制协处理器，本次实验我们需要通过CP0实现对TLB、MMU及异常处理的管理机制。

下表列出了CP0的寄存器及其功能，这里我们只给出必须实现的11个寄存器。

\begin{table}[H]
\centering
\begin{tabular}{lll}
\hline
编号&寄存器名称&寄存器功能\\
\hline
0&Index&用于TLBWI指令访问TLB入口的索引序号\\
2&EntryLo0&作为TLBWI及其他TLB指令接口，管理偶数页入口\\
3&EntryLo1&作为TLBWI及其他TLB指令接口，管理奇数页入口\\
9&BadVAddr&捕捉最近一次地址错误或TLB异常（重填、失效、修改）时的虚拟地址\\
10&Count&每隔一个时钟增加1，用作计数器，并可使能控制\\
11&EntryHi&TLB异常时，系统将虚拟地址部分写入EntryHi寄存器中用于TLB匹配信息\\
12&Compare&保持一定值，当Count值与Compare相等时，SI$\_$TimerInt引脚变高电平直到有数值写入Compare，用于定时中断\\
13&Status&表示处理器的操作模式、中断使能及诊断状态\\
15&Cause&记录最近一次异常的原因，控制软件中断请求以及中断处理派分的向量\\
16&EPC&存储异常处理之后程序恢复执行的地址\\
18&EBase&识别多处理器系统中不同的处理器异常向量的基地址\\
\hline
\end{tabular}
\end{table}

\begin{enumerate}[(1)]
\item Index寄存器
Index寄存器是一个32位读/写寄存器，可用于TLBP、TLBR和TLBWI指令访问TLB入口的索引序号。

Index区域的大小根据具体实现方式随TLB的入口个数而定。对于基于TLB的内存管理单元MMU来说，该区域的最小值为$\lceil log_{2}(TLBEntries)\rceil$。

如果一个写入Index寄存器的值大于等于TLB入口数，则该处理器的操作是未定义的。

该寄存器仅对TLB有效。

\item EntryLo1/EntryLo0寄存器
这对EntryLo寄存器的作用等同于TLB、TLBR、TLBWI和TLBWR指令间的接口。对基于TLB的MMU而言，EntryLo0管理偶数页的入口，EntryLo1管理奇数页的入口。如果出现了地址错误，TLB失效，TLB修改或是TLB重填异常的行为，那么EntryLo0和EntryLo1寄存器的内容将会成为未定义的。只有当基于TLB的存储管理单元存在时，这些寄存器才有效。
\item EntryHi寄存器
\item Status寄存器
\item Cause寄存器
\item Ebase寄存器
\end{enumerate}

\subsubsection{异常中断处理}
本次实验要求实现精确异常处理，以下是一些可能用到的中断及异常的情况

\begin{table}[H]
\centering
\begin{tabular}{lll}
\hline
异常号&异常名&描述\\
\hline
0&Interrupt&外部中断、异步发生，由硬件引起\\
1&TLB Modified&内存修改异常，发生在Memory阶段\\
2&TLBL&读未在TLB中映射的内存地址触发的异常\\
3&TLBS&写未在TLB中映射的内存地址触发的异常\\
4&ADEL&读访问一个非对齐地址触发的异常\\
5&ADES&读访问一个非对齐地址触发的异常\\
8&SYSCALL&系统调用\\
10&RI&执行未定义指令异常\\
11&Co-Processor Unavailable&试图访问不存在的协处理器异常\\
23&Watch&Watch寄存器监控异常\\
\hline
\end{tabular}
\end{table}

下表列出可能用到的中断号

\begin{table}[H]
\centering
\begin{tabular}{ll}
\hline
中断号&设备\\
\hline
0&系统计时器\\
1&键盘\\
3&通讯端口COM2\\
4&通讯端口COM1\\
\hline
\end{tabular}
\end{table}

中断/异常处理的一般流程如下：

\begin{enumerate}[(1)]
\item 保存中断信息，主要是EPC，BadVaddr，Status，Cause等寄存器的信息

\qquad EPC:存储异常处理之后程序恢复执行的地址。对于一般异常，当前发生错误的指令地址即为EPC应当保存的地址；而对于硬件中断，由于是异步产生则可以任意设定一条并未执行完成的指令地址保存，但在进入下一步处理之前，该指令前的指令都应当被执行完。

\qquad BadVAddr：捕捉最近一次地址错误或TLB异常（重填、失效、修改）时的虚拟地址。

\qquad Status：将EXL位置为1，进入kernel模式进行中断处理。

\qquad Cause：记录下异常号。

\qquad EntryHi：TLB异常时，记录下BadVAddr的部分高位。

\item 根据Cause中的异常号跳转到相应的异常处理函数入口

\item 中断处理

\item 通过调用ERET指令恢复现场，返回EPC所存地址执行并且将Status中的EXL重置为0表示进入user模式。

\end{enumerate}

\qquad 

实现步骤：

\begin{enumerate}[(1)]
\item 在可能发生异常的位置实现对异常的记录。

\begin{enumerate}[(a)]
\item 访存时可能发生ADEL，ADES，TLBM，TLBL，TLBS，Watch异常

\item 译码后可能发生RI，SYSCALL，Co-ProcessorU异常
\end{enumerate}
\item 实现对中断的记录。

\begin{enumerate}[(a)]
\item 硬件产生中断时将信息写入CP0寄存器
\end{enumerate}

\item 根据异常记录信息判断是否产生异常。

\item 进入异常处理流程。

\end{enumerate}

\subsubsection{MMU}
\paragraph{虚拟地址映射}
\paragraph{TLB}

\subsection{Ucore}
\subsubsection{BIOS}
BIOS即为启动ucore所用的Bootloader程序，通常是放在Flash中。而本实验中我们将在FPGA里建立一块ROM，将Bootloader放置在该ROM中，并且设置CPU的访问地址从该ROM开始。这样能避免由于Flash的读写不稳定而对BIOS造成的破坏，还能将ucore与其独立开来。

BIOS启动时，Flash中的操作系统加载到内存中，然后跳转到操作系统的初始化代码，从而开始操作系统的工作。
\subsubsection{远程文件执行}
实验要求修改ucore，实现简单的远程文件执行功能，即通过串口从PC上获取ELF文件，并在本地执行。
\subsection{外设}
\subsubsection{串口}
串口的功能需求为实现与PC机的通信，通过计算机键盘输入数据，向计算机输出数据。

串口模块的主要部分位于板子上的CPLD中，在FPGA端，对串口的控制通过data$\_$ready、tbre、\\
tsre、rdn、wrn进行。

当data$\_$ready=‘1’时串口数据就绪，可以读出。

当tbre and tsre=‘1’是，表示可以向串口写入。

将rdn置‘0’且数据线写高阻，可以从数据线得出串口数据。

将数据写入数据线且将wrn置‘0’，可以向串口发出数据。

串口模块1FD003F8地址表示数据（只有低8位有效），必须使用SW指令写入。

1FD003FC地址表示状态寄存器Status，Status$\&$1=1时可写，Status$\&$2=2时可读。
\subsubsection{VGA}
Device$\_$VGA模块是显示控制模块，接受CPU写入的ASCII码数据，并维护一个字符矩阵，以字符中断的形式通过VGA接口输出到显示器。

CPU需要从1FC03000地址读出数据，如果结果为‘1’表示可以写入，否则不能吸入；可以写入时，向1FC03000地址写入ASCII数据即可。
\subsubsection{ps/2键盘}
Device$\_$Keyboard模块位键盘控制模块。只要从0F000000地址读出数据，结果为0表示没有新数据，否则读到的就是键入的ASCII码。

PS/2键盘读到的是扫描码，为了方便软件，可以在硬件层面加入编码转换，CPU读到的直接就是ASCII码。
\subsubsection{网口}
这是拓展要求。实验提供了DM9000A网口芯片与PC机进行网络通讯。该芯片带有通用处理器接口的以太网控制器，一个10/100M PHY和4K双字的SRAM，IO端口支持3.3V与5V容限值。

当收到数据包时，芯片通过中断信号方式通知CPU触发异常，由操作系统对数据包进行处理。若要完成此需求，则需对操作系统进行改写：在初始化时添加网口中断使能、添加网口芯片初始化代码、手动实现网络通信协议和网口驱动等。
\subsection{Decaf编译器}
\subsubsection{汇编指令的生成}
由于简化的CPU中并未实现add、sub指令，需要把decaf的MIPS后端里生成add、sub指令的部分改成addu、subu，区别仅在于溢出时后者不会产生异常。

另外、CPU中也未实现除法指令，不过由于所用测试程序中没有除法运算，因此不进行相关修改。如果需要除法，可以用其它指令手动实现除法函数，并把除法翻译成函数调用。
\subsubsection{库函数调用及calling convention}
标准MIPS32使用032 ABI，函数调用的前四个参数通过\$a0-\$a3四个寄存器传输；但decaf编译出的程序的参数全都在栈上传递。当然，无论什么calling convention，只要能自恰，程序本身就应该能正常运行，所以需要解决的问题只有用于程序与C实现的库函数及操作系统交互的部分。

在这里，我们在decaf和库函数之间增加一个适配器层，将decaf的调用约定翻译成032 ABI再调用库函数。
\subsubsection{程序入口及退出}
直接使用ucore里的linker script(user.Id)以及用户静态函数库libuser.a，在该环境下系统会设置好一些全局变量，然后跳转到main执行。我们将修改decaf编译器，将其输出的main重命名为decaf$\_$main，然后汇编实现一个新的main函数。由于decaf的main是void类型，我们默认其执行成功返回0，于是在decaf$\_$main返回后直接调用exit(0)。
\subsection{指令集与数据通路}
