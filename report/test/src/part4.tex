\section{特殊情况测试}
\subsection{与数据冲突有关的测试}

与数据冲突有关的测试主要分为普通寄存器的数据冲突、HILO寄存器的数据冲突、CP0寄存器的数据冲突和load相关问题。

\begin{enumerate}

\item 普通寄存器的数据冲突

普通寄存器的数据冲突是指连续两条指令访问同一寄存器，且第二条指令译码阶段需要依赖第一条指令得出的寄存器值时，由于第一条指令不能及时写回寄存器而导致的数据冲突。在这种情况下，只需令第一条指令在检测到相关问题时将数据前推回译码阶段即可。

\item HILO寄存器的数据冲突

与普通寄存器的数据冲突类似，只需在检测到相关问题时令数据前推即可。

\item CP0寄存器的数据冲突

与普通寄存器的数据冲突类似，只需在检测到相关问题时令数据前推即可。

\item load相关问题

load相关问题是指load类指令后接branch类指令，branch类指令需要依赖load类指令所写回的寄存器值，而load类指令来不及写回寄存器导致的。在这种情况下数据前推也来不及，因此需要插入气泡，使得回写、访存、执行阶段继续执行，而取指和译码阶段暂停。这样load类指令可以在访存阶段得到正确的值并前推回译码阶段，使得branch类指令能得到正确值。

\end{enumerate}

对这四种情况分别进行了测试，分别为测试样例2、6、12、11.

普通寄存器的数据冲突一开始没有解决，后来发现是因为某个变量的错别字。改正后测试通过。

\subsection{与结构冲突有关的测试}

结构冲突是指取指阶段和访存阶段同时需要访问存储器时产生的冲突。为了解决这个问题，我们在CPU与外设之间加入了总线，并在总线上实现了仲裁器。

仲裁器的修改耗时较长，最后确定了写法后测试通过。样例主要为加载存储类指令。对应样例为测试样例9

\subsection{与控制冲突有关的测试}

因为我们的CPU中引入了延时槽的设计，所以不会有控制冲突问题。为了测试延时槽中指令是否能正确执行，测试样例中延时槽中指令并不是nop而是其它运算指令。具体样例为测试样例8至9，测试均通过。
